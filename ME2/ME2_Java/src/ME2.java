import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;

import org.apache.commons.math3.distribution.UniformRealDistribution;
import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.distribution.NormalDistribution;

public class ME2 {
	private String functionName;
	private int executionCount;
	private double lower;
	private double upper;

	private final int dim;
	private int GEN;
	private int exploit_GEN;
	private int SAMPLE_SIZE;
	private int NUM_OF_NEIGHBOURS;

	private int factor;
	private int overfactor;
	int noOfGeneration;
	double[][] sample;
	double[][] sigma;
	double[][] neighs;

	double[][] matrixData;
	RealMatrix zeta;
	RealMatrix delta;

	double[] bestFitnessesPerGen;
	int[] noOfEvalsPerGen;

	class Node implements Comparable<Node> {
		int index;
		double fitness;

		Node() {
			index = 0;
			fitness = 0;
		}

		@Override
		public int compareTo(Node o) {
			return (int) Double.compare(o.fitness, this.fitness);
		}
	};

	public ME2(String functionName, int dim, int sampleSize, int neighbourSize, int executionCount) {
		System.out.println("functionName: " + functionName 
				+ " dim:" + dim 
				+ " sampleSize:" + sampleSize
				+ " neighbour:" + neighbourSize
				+ " executionCount: " + executionCount);
		this.functionName = functionName;
		this.executionCount = executionCount;
		setFunctionRange();

		this.dim = dim;
		this.GEN = 150;
		this.exploit_GEN = 50;
		this.SAMPLE_SIZE = sampleSize;
		this.NUM_OF_NEIGHBOURS = neighbourSize;

		this.factor = 10;
		this.overfactor = factor * SAMPLE_SIZE;
		this.noOfGeneration = 0;
		this.sample = new double[SAMPLE_SIZE][dim];
		this.sigma = new double[SAMPLE_SIZE][dim];
		this.neighs = new double[overfactor][dim];

		this.matrixData = new double[dim][1];
		this.zeta = MatrixUtils.createRealMatrix(matrixData);
		this.delta = MatrixUtils.createRealMatrix(matrixData);

		this.bestFitnessesPerGen = new double[GEN + exploit_GEN];
		this.noOfEvalsPerGen = new int[GEN + exploit_GEN];
		
		for (int j = 0; j < sample.length; j++)
			for (int i = 0; i < sample[j].length; i++)
				sample[j][i] = 0;

		for (int j = 0; j < sample.length; j++)
			for (int i = 0; i < sample[j].length; i++)
				sigma[j][i] = 1;

	}

	public void map() {
		System.out.println("ME2: map");

		UniformRealDistribution realDist = new UniformRealDistribution(lower, upper);

		for (int j = 0; j < dim; j++) {
			for (int i = 0; i < overfactor; i++) {
				neighs[i][j] = realDist.sample();
			}
		}

		int indexer = 0;

		// Choose the final sample for the next stage
		for (int i = 0; i < overfactor;) {

			double tempFitness = fitness(neighs[i]);
			double tempFitness2 = tempFitness;

			int pos = 0;
			// choose best solution from the rest samples subset
			for (int j = 1; j < factor; j++) {
				tempFitness2 = fitness(neighs[i + j]);
				if (tempFitness2 > tempFitness) {
					pos = i + j;
					tempFitness = tempFitness2;
				}
			}

			sample[indexer++] = neighs[pos];
			if (indexer >= SAMPLE_SIZE)
				break;

			i += factor;
		}
		for (int i = 0; i < bestFitnessesPerGen.length; i++) {
			bestFitnessesPerGen[i] = -Double.MAX_VALUE;
			noOfEvalsPerGen[i] = 0;
		}
	}
	
	void printSamples(int s) throws FileNotFoundException, UnsupportedEncodingException {

		PrintWriter stepFile = new PrintWriter("Step2-" + s, "UTF-8");

		for (int i = 0; i < SAMPLE_SIZE; i++) {
			for (int j = 0; j < dim; j++) {
				stepFile.print(sample[i][j] + " ");
			}
			stepFile.print(" " + fitness(sample[i]) + "\n");
		}
		stepFile.close();
	}

	public void exploreAndExploit() throws FileNotFoundException, UnsupportedEncodingException {
		System.out.println("ME2: exploreAndExploit");

		for (int i = 0; i < sample.length; i++) {
			explore(sample[i], i);
//			printSamples(i+2);
		}
		
		for (int i = 0; i < sample.length; i++) {
			exploit(sample[i], i);
//			printSamples(i+51);
		}
		
		if(noOfGeneration < (GEN + exploit_GEN)) {
			double bestFitnessValue = bestFitnessesPerGen[noOfGeneration];
			while(noOfGeneration < (GEN + exploit_GEN)){
				bestFitnessesPerGen[noOfGeneration++] = bestFitnessValue;
			}
		}

		PrintWriter trackFile = new PrintWriter("track-" + functionName + "-" + dim + "-" + SAMPLE_SIZE + "-" + NUM_OF_NEIGHBOURS + "-" + executionCount + ".txt",
				"UTF-8");

		for (int i = 0; i < bestFitnessesPerGen.length; i++)
			trackFile.println(i + " " + bestFitnessesPerGen[i] + " " + noOfEvalsPerGen[i]);

		trackFile.close();
		
		int totalNoOfEvaluations = 0;
		for (int i = 0; i < noOfEvalsPerGen.length; i++) {
			totalNoOfEvaluations += noOfEvalsPerGen[i];
		}
		System.out.println("Total No Of Evaluations: " + totalNoOfEvaluations + " ");

	}

	private void explore(double[] oneSample, int sampleIndex) {
		noOfGeneration = 0;
		double[] tempSample = Arrays.copyOf(oneSample, oneSample.length);

		double[] bestNeighbour = Arrays.copyOf(oneSample, oneSample.length);
		double[] bestOfAll = Arrays.copyOf(oneSample, oneSample.length);
		double bestFitnessValue = fitness(bestNeighbour);
		Node[] nodeFitnessArray = new Node[NUM_OF_NEIGHBOURS];
		for (int n = 0; n < nodeFitnessArray.length; n++) {
			nodeFitnessArray[n] = new Node();
		}
		double[][] localNeighbors = new double[NUM_OF_NEIGHBOURS][dim];
		double c = Math.sqrt(1.0 / dim);
		int pos = 0;
		double beta = Math.sqrt(1.0 / dim);
		double beta_s = 1.0 / dim;

		double tempSampleFitness = bestFitnessValue;

		NormalDistribution normalDistribution = new NormalDistribution(0, 1);

		double sip = 1;

		for (int col = 0; col < zeta.getColumnDimension(); col++)
			for (int row = 0; row < zeta.getRowDimension(); row++)
				zeta.setEntry(row, col, 0);

		for (int col = 0; col < zeta.getColumnDimension(); col++)
			for (int row = 0; row < zeta.getRowDimension(); row++)
				delta.setEntry(row, col, 1);

		double minNeighborFitness = Double.MAX_VALUE; // FLT_MAX is the maximum
														// float number.

		while (noOfGeneration < GEN) {
			minNeighborFitness = Double.MAX_VALUE;
			double newTempNeighbor = 0;

			for (int i = 0; i < NUM_OF_NEIGHBOURS; i++) {
				double[] normalDistVector = new double[dim];

				for (int k = 0; k < dim; k++)
					normalDistVector[k] = normalDistribution.sample();
				RealMatrix normalMatrix = MatrixUtils.createColumnRealMatrix(normalDistVector);
				for (int j = 0; j < dim; j++) {
					newTempNeighbor = tempSample[j] + sip * delta.transpose().multiply(normalMatrix).getEntry(0, 0);
					if (newTempNeighbor > upper)
						localNeighbors[i][j] = upper;
					else if (newTempNeighbor < lower)
						localNeighbors[i][j] = lower;
					else
						localNeighbors[i][j] = newTempNeighbor;
				}
				double newNeighborFitness = fitness(localNeighbors[i]);

				if (newNeighborFitness < minNeighborFitness) {
					minNeighborFitness = newNeighborFitness;
				}

				nodeFitnessArray[i].index = i;
				nodeFitnessArray[i].fitness = newNeighborFitness;
			}

			// The following part is implementation of roulette wheel method
			double rate = 0;
			UniformRealDistribution dice = new UniformRealDistribution(0.5, 1);
			double totalFitness = 0;
			for (int i = 0; i < NUM_OF_NEIGHBOURS; i++) {
				nodeFitnessArray[i].fitness -= minNeighborFitness;
				totalFitness += nodeFitnessArray[i].fitness;
			}

			for (int i = 0; i < NUM_OF_NEIGHBOURS; i++) {
				nodeFitnessArray[i].fitness = nodeFitnessArray[i].fitness / totalFitness;
			}

			Arrays.sort(nodeFitnessArray);
			rate = dice.sample(); // rand() % (pm - 1) / (double)pm;
			pos = 0;
			double cul_pro = 0;

			for (int i = NUM_OF_NEIGHBOURS - 1; i >= 0; i--) {
				cul_pro += nodeFitnessArray[i].fitness;
				if (cul_pro >= rate) {
					pos = i;
					break;
				}
			}
			// end of roulette wheel

			double[] omean = tempSample;
			// pseudo code line 16
			tempSample = Arrays.copyOf(localNeighbors[nodeFitnessArray[pos].index], dim);
			tempSampleFitness = fitness(tempSample);

			if (tempSampleFitness > bestFitnessValue) {
				bestFitnessValue = tempSampleFitness;
				bestOfAll = Arrays.copyOf(tempSample, dim);
			}

			// The following implements from the line 21 to line 24
			for (int i = 0; i < dim; i++) {
				zeta.setEntry(i, 0,
						(1 - c) * zeta.getEntry(i, 0) - c * (tempSample[i] - omean[i]) / (sip * delta.getEntry(i, 0)));
			}

			sip *= Math.pow((Math.exp(zeta.getNorm() / Math.sqrt(dim * c / (2 - c)) - 1 + 1.0 / (5 * dim))), beta);

			for (int i = 0; i < dim; i++) {
				delta.setEntry(i, 0, delta.getEntry(i, 0)
						* Math.pow((Math.abs(zeta.getEntry(i, 0)) * Math.sqrt((2 - c) / c) + 0.35), beta_s));
			}
			// end of line 21 to line 24

			if (bestFitnessesPerGen[noOfGeneration] <= bestFitnessValue) {
				bestFitnessesPerGen[noOfGeneration] = bestFitnessValue;
			}
			noOfGeneration++;
		}

		for (int i = 0; i < dim; i++) {
			sigma[sampleIndex][i] = delta.getEntry(i, 0);
		}
		sample[sampleIndex] = bestOfAll;
	}

	private void exploit(double[] oneSample, int sampleIndex) {
		noOfGeneration = GEN - 1;

		double[] gradien = new double[dim];
		double delta = 0.001;

		while (noOfGeneration < (GEN + exploit_GEN - 1)) {
			double[] tempSample = Arrays.copyOf(oneSample, dim);
			double[] tempSample1 = Arrays.copyOf(oneSample, dim);
			noOfGeneration++;

			for (int i = 0; i < dim; i++) {
				delta = 0.001 * sigma[sampleIndex][i];
				tempSample1[i] += delta;
				tempSample[i] -= delta;
				gradien[i] = (fitness(tempSample1) - fitness(tempSample)) / delta / 2;
				tempSample1[i] = oneSample[i];
				tempSample[i] = oneSample[i];
				sigma[sampleIndex][i] = 0.5;
			}

			for (int i = 0; i < dim; i++) {
				tempSample[i] += sigma[sampleIndex][i] * gradien[i];

				if (tempSample[i] > upper || tempSample[i] < lower) {
					tempSample[i] = oneSample[i];
					sigma[sampleIndex][i] /= 2;
				}
			}
			double bestFitness = fitness(tempSample);
			double sampleFitness = fitness(oneSample);

			if (sampleFitness >= bestFitness)
				bestFitness = sampleFitness;

			if (bestFitnessesPerGen[noOfGeneration] <= bestFitness) {
				bestFitnessesPerGen[noOfGeneration] = bestFitness;
			}

			if (sampleFitness >= bestFitness) {
				tempSample = Arrays.copyOf(oneSample, dim);

				for (int i = 0; i < dim; i++)
					sigma[sampleIndex][i] /= 2;

				continue;
			}

			if (Math.abs(fitness(oneSample) - fitness(tempSample)) < 0.00000000000001) {
				System.out.println("noOfGeneration " + noOfGeneration);
				break;
			}

			oneSample = Arrays.copyOf(tempSample, dim);
		}
		sample[sampleIndex] = oneSample;
	}

	private double fitness(double[] param) {
		double toReturn = 0;
		switch (functionName) {
		case "Ackley":
			toReturn = TestFunction.Ackley(param);
			break;
		case "Hump6":
			toReturn = TestFunction.Hump6(param);
			break;
		case "Branin":
			toReturn = TestFunction.Branin(param);
			break;
		case "Matyas":
			toReturn = TestFunction.Matyas(param);
			break;
		case "Beale":
			toReturn = TestFunction.Beale(param);
			break;
		case "Rosenbrock":
			toReturn = TestFunction.Rosenbrock(param);
			break;
		case "Schaffer":
			toReturn = TestFunction.Schaffer(param);
			break;
		case "Griewank":
			toReturn = TestFunction.Griewank(param);
			break;
		case "Rastr":
			toReturn = TestFunction.Rastr(param);
			break;
		case "Schwefel":
			toReturn = TestFunction.Schwefel(param);
			break;
		case "Sphere":
			toReturn = TestFunction.Sphere(param);
			break;
		}
		noOfEvalsPerGen[noOfGeneration]++;
		return -toReturn;
	}

	private void setFunctionRange() {
		switch (functionName) {
		case "Ackley":
			lower = -32.768;
			upper = 32.768;
			break;
		case "Hump6":
			lower = -3;
			upper = 3;
			break;
		case "Branin":
			lower = -5;
			upper = 15;
			break;
		case "Matyas":
			lower = -10;
			upper = 10;
			break;
		case "Beale":
			lower = -4.5;
			upper = 4.5;
			break;
		case "Rosenbrock":
			lower = -2.048;
			upper = 2.048;
			break;
		case "Schaffer":
			lower = -100;
			upper = 100;
			break;
		case "Griewank":
			lower = -600;
			upper = 600;
			break;
		case "Rastr":
			lower = -5.12;
			upper = 5.12;
			break;
		case "Schwefel":
			lower = -512.03;
			upper = 511.97;
			break;
		case "Sphere":
			lower = -5.12;
			upper = 5.12;
			break;
		}
		System.out.println("upper: " + upper + " lower: " + lower);
	}
}
