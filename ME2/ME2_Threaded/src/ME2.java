import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.math3.distribution.UniformRealDistribution;
import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.distribution.NormalDistribution;

public class ME2 {
	private String functionName;
	private int executionCount;
	private int threadCount;
	private double lower;
	private double upper;

	private final int dim;
	private int GEN;
	private int exploit_GEN;
	private int SAMPLE_SIZE;
	private int NUM_OF_NEIGHBOURS;

	private int factor;
	private int overfactor;
	double[][] sample;
	double[][] sigma;
	double[][] neighs;

	double[] bestFitnessesPerGen;
	int[] noOfEvalsPerGen;

	class Node implements Comparable<Node> {
		int index;
		double fitness;

		Node() {
			index = 0;
			fitness = 0;
		}

		@Override
		public int compareTo(Node o) {
			return (int) Double.compare(o.fitness, this.fitness);
		}
	};

	public ME2(String functionName, int dim, int sampleSize, int neighbourSize, int executionCount, int threadCount) {
		System.out.println("functionName: " + functionName 
				+ " dim:" + dim 
				+ " sampleSize:" + sampleSize
				+ " neighbour:" + neighbourSize
				+ " executionCount: " + executionCount
				+ " threadCount: " + threadCount);
		this.functionName = functionName;
		this.executionCount = executionCount;
		this.threadCount = threadCount;
		setFunctionRange();

		this.dim = dim;
		this.GEN = 150;
		this.exploit_GEN = 50;
		this.SAMPLE_SIZE = sampleSize;
		this.NUM_OF_NEIGHBOURS = neighbourSize;

		this.factor = 10;
		this.overfactor = factor * SAMPLE_SIZE;
		this.sample = new double[SAMPLE_SIZE][dim];
		this.sigma = new double[SAMPLE_SIZE][dim];
		this.neighs = new double[overfactor][dim];

		this.bestFitnessesPerGen = new double[GEN + exploit_GEN];
		this.noOfEvalsPerGen = new int[GEN + exploit_GEN];
		
		for (int j = 0; j < sample.length; j++)
			for (int i = 0; i < sample[j].length; i++)
				sample[j][i] = 0;

		for (int j = 0; j < sigma.length; j++)
			for (int i = 0; i < sigma[j].length; i++)
				sigma[j][i] = 1;

	}

	public void map() {
		System.out.println("ME2: map");

		UniformRealDistribution realDist = new UniformRealDistribution(lower, upper);

		for (int j = 0; j < dim; j++) {
			for (int i = 0; i < overfactor; i++) {
				neighs[i][j] = realDist.sample();
			}
		}

		int indexer = 0;
		int noOfGeneration = 0;
		// Choose the final sample for the next stage
		for (int i = 0; i < overfactor;) {

			double tempFitness = fitness(neighs[i], noOfGeneration);
			double tempFitness2 = tempFitness;

			int pos = 0;
			// choose best solution from the rest samples subset
			for (int j = 1; j < factor; j++) {
				tempFitness2 = fitness(neighs[i + j], noOfGeneration);
				if (tempFitness2 > tempFitness) {
					pos = i + j;
					tempFitness = tempFitness2;
				}
			}

			sample[indexer++] = neighs[pos];
			if (indexer >= SAMPLE_SIZE)
				break;

			i += factor;
		}
		for (int i = 0; i < bestFitnessesPerGen.length; i++) {
			bestFitnessesPerGen[i] = -Double.MAX_VALUE;
			noOfEvalsPerGen[i] = 0;
		}
	}

	public void exploreAndExploit() throws FileNotFoundException, UnsupportedEncodingException, InterruptedException {
		System.out.println("ME2: exploreAndExploit");

		for (int i = 0; i < sample.length;) {
			List<Thread> threadList = new ArrayList<Thread>();
			for(int count = 0; count < threadCount && i < sample.length; count++, i++) {
				Thread thread = new Thread(new Explore(sample[i], i));
				thread.start();
				threadList.add(thread);				
			}
			for (Thread t: threadList) {
				t.join(); 
			}				
		}
		
//        int noOfGeneration = 0;
//		if(noOfGeneration < (GEN + exploit_GEN)) {
//			double bestFitnessValue = bestFitnessesPerGen[noOfGeneration];
//			while(noOfGeneration < (GEN + exploit_GEN)){
//				bestFitnessesPerGen[noOfGeneration++] = bestFitnessValue;
//			}
//		}

		PrintWriter trackFile = new PrintWriter("track-" + functionName + "-" + dim + "-" + SAMPLE_SIZE + "-" + NUM_OF_NEIGHBOURS + "-" + executionCount + ".txt",
				"UTF-8");

		for (int i = 0; i < bestFitnessesPerGen.length; i++)
			trackFile.println(i + " " + bestFitnessesPerGen[i] + " " + noOfEvalsPerGen[i]);

		trackFile.close();
		
		int totalNoOfEvaluations = 0;
		for (int i = 0; i < noOfEvalsPerGen.length; i++) {
			totalNoOfEvaluations += noOfEvalsPerGen[i];
		}
		System.out.println("Total No Of Evaluations: " + totalNoOfEvaluations + " ");

	}
	
	class Explore implements Runnable {
		
		private double[] oneSample;
		private int sampleIndex;
		
		private double[][] matrixData;
		private RealMatrix zeta;
		private RealMatrix delta;
		
		public Explore(double[] oneSample, int sampleIndex) {
			this.oneSample = oneSample;
			this.sampleIndex = sampleIndex;
			
			this.matrixData = new double[dim][1];
			this.zeta = MatrixUtils.createRealMatrix(matrixData);
			this.delta = MatrixUtils.createRealMatrix(matrixData);
		}
		
		@Override
		public void run() {
			int noOfGeneration = 0;
			double[] tempSample = Arrays.copyOf(oneSample, oneSample.length);

			double[] bestNeighbour = Arrays.copyOf(oneSample, oneSample.length);
			double[] bestOfAll = Arrays.copyOf(oneSample, oneSample.length);
			double bestFitnessValue = fitness(bestNeighbour, noOfGeneration);
			Node[] nodeFitnessArray = new Node[NUM_OF_NEIGHBOURS];
			for (int n = 0; n < nodeFitnessArray.length; n++) {
				nodeFitnessArray[n] = new Node();
			}
			double[][] localNeighbors = new double[NUM_OF_NEIGHBOURS][dim];
			double c = Math.sqrt(1.0 / dim);
			int pos = 0;
			double beta = Math.sqrt(1.0 / dim);
			double beta_s = 1.0 / dim;

			double tempSampleFitness = bestFitnessValue;

			NormalDistribution normalDistribution = new NormalDistribution(0, 1);

			double sip = 1;

			for (int col = 0; col < zeta.getColumnDimension(); col++)
				for (int row = 0; row < zeta.getRowDimension(); row++)
					zeta.setEntry(row, col, 0);

			for (int col = 0; col < zeta.getColumnDimension(); col++)
				for (int row = 0; row < zeta.getRowDimension(); row++)
					delta.setEntry(row, col, 1);

			double minNeighborFitness = Double.MAX_VALUE; // FLT_MAX is the maximum
															// float number.

			while (noOfGeneration < GEN) {
				minNeighborFitness = Double.MAX_VALUE;
				double newTempNeighbor = 0;

				for (int i = 0; i < NUM_OF_NEIGHBOURS; i++) {
					double[] normalDistVector = new double[dim];

					for (int k = 0; k < dim; k++)
						normalDistVector[k] = normalDistribution.sample();
					RealMatrix normalMatrix = MatrixUtils.createColumnRealMatrix(normalDistVector);
					for (int j = 0; j < dim; j++) {
						newTempNeighbor = tempSample[j] + sip * delta.transpose().multiply(normalMatrix).getEntry(0, 0);
						if (newTempNeighbor > upper)
							localNeighbors[i][j] = upper;
						else if (newTempNeighbor < lower)
							localNeighbors[i][j] = lower;
						else
							localNeighbors[i][j] = newTempNeighbor;
					}
					double newNeighborFitness = fitness(localNeighbors[i], noOfGeneration);

					if (newNeighborFitness < minNeighborFitness) {
						minNeighborFitness = newNeighborFitness;
					}

					nodeFitnessArray[i].index = i;
					nodeFitnessArray[i].fitness = newNeighborFitness;
				}

				// The following part is implementation of roulette wheel method
				double rate = 0;
				UniformRealDistribution dice = new UniformRealDistribution(0.5, 1);
				double totalFitness = 0;
				for (int i = 0; i < NUM_OF_NEIGHBOURS; i++) {
					nodeFitnessArray[i].fitness -= minNeighborFitness;
					totalFitness += nodeFitnessArray[i].fitness;
				}

				for (int i = 0; i < NUM_OF_NEIGHBOURS; i++) {
					nodeFitnessArray[i].fitness = nodeFitnessArray[i].fitness / totalFitness;
				}

				Arrays.sort(nodeFitnessArray);
				rate = dice.sample(); // rand() % (pm - 1) / (double)pm;
				pos = 0;
				double cul_pro = 0;

				for (int i = NUM_OF_NEIGHBOURS - 1; i >= 0; i--) {
					cul_pro += nodeFitnessArray[i].fitness;
					if (cul_pro >= rate) {
						pos = i;
						break;
					}
				}
				// end of roulette wheel

				double[] omean = tempSample;
				// pseudo code line 16
				tempSample = Arrays.copyOf(localNeighbors[nodeFitnessArray[pos].index], dim);
				tempSampleFitness = fitness(tempSample, noOfGeneration);

				if (tempSampleFitness > bestFitnessValue) {
					bestFitnessValue = tempSampleFitness;
					bestOfAll = Arrays.copyOf(tempSample, dim);
				}

				// The following implements from the line 21 to line 24
				for (int i = 0; i < dim; i++) {
					zeta.setEntry(i, 0,
							(1 - c) * zeta.getEntry(i, 0) - c * (tempSample[i] - omean[i]) / (sip * delta.getEntry(i, 0)));
				}

				sip *= Math.pow((Math.exp(zeta.getNorm() / Math.sqrt(dim * c / (2 - c)) - 1 + 1.0 / (5 * dim))), beta);

				for (int i = 0; i < dim; i++) {
					delta.setEntry(i, 0, delta.getEntry(i, 0)
							* Math.pow((Math.abs(zeta.getEntry(i, 0)) * Math.sqrt((2 - c) / c) + 0.35), beta_s));
				}
				// end of line 21 to line 24

				if (bestFitnessesPerGen[noOfGeneration] <= bestFitnessValue) {
					bestFitnessesPerGen[noOfGeneration] = bestFitnessValue;
				}
				noOfGeneration++;
			}

			for (int i = 0; i < dim; i++) {
				sigma[sampleIndex][i] = delta.getEntry(i, 0);
			}
			sample[sampleIndex] = bestOfAll;
			
			new Thread(new Exploit(sample[sampleIndex], sampleIndex)).start();
		}		
	}
	
	class Exploit implements Runnable {
		
		private double[] oneSample;
		private int sampleIndex;
		
		public Exploit(double[] oneSample, int sampleIndex) {
			this.oneSample = oneSample;
			this.sampleIndex = sampleIndex;
		}

		@Override
		public void run() {
			int noOfGeneration = GEN - 1;

			double[] gradien = new double[dim];
			double delta = 0.001;

			while (noOfGeneration < (GEN + exploit_GEN - 1)) {
				double[] tempSample = Arrays.copyOf(oneSample, dim);
				double[] tempSample1 = Arrays.copyOf(oneSample, dim);
				noOfGeneration++;

				for (int i = 0; i < dim; i++) {
					delta = 0.001 * sigma[sampleIndex][i];
					tempSample1[i] += delta;
					tempSample[i] -= delta;
					gradien[i] = (fitness(tempSample1, noOfGeneration) - fitness(tempSample, noOfGeneration)) / delta / 2;
					tempSample1[i] = oneSample[i];
					tempSample[i] = oneSample[i];
					sigma[sampleIndex][i] = 0.5;
				}

				for (int i = 0; i < dim; i++) {
					tempSample[i] += sigma[sampleIndex][i] * gradien[i];

					if (tempSample[i] > upper || tempSample[i] < lower) {
						tempSample[i] = oneSample[i];
						sigma[sampleIndex][i] /= 2;
					}
				}
				double bestFitness = fitness(tempSample, noOfGeneration);
				double sampleFitness = fitness(oneSample, noOfGeneration);

				if (sampleFitness >= bestFitness)
					bestFitness = sampleFitness;

				if (bestFitnessesPerGen[noOfGeneration] <= bestFitness) {
					bestFitnessesPerGen[noOfGeneration] = bestFitness;
				}

				if (sampleFitness >= bestFitness) {
					tempSample = Arrays.copyOf(oneSample, dim);

					for (int i = 0; i < dim; i++)
						sigma[sampleIndex][i] /= 2;

					continue;
				}

				if (Math.abs(fitness(oneSample, noOfGeneration) - fitness(tempSample, noOfGeneration)) < 0.00000000000001) {
					System.out.println("noOfGeneration " + noOfGeneration);
					break;
				}

				oneSample = Arrays.copyOf(tempSample, dim);
			}
			sample[sampleIndex] = oneSample;
			
		}
		
	}

	private double fitness(double[] param, int noOfGeneration) {
		double toReturn = 0;
		switch (functionName) {
		case "Ackley":
			toReturn = TestFunction.Ackley(param);
			break;
		case "Hump6":
			toReturn = TestFunction.Hump6(param);
			break;
		case "Branin":
			toReturn = TestFunction.Branin(param);
			break;
		case "Matyas":
			toReturn = TestFunction.Matyas(param);
			break;
		case "Beale":
			toReturn = TestFunction.Beale(param);
			break;
		case "Rosenbrock":
			toReturn = TestFunction.Rosenbrock(param);
			break;
		case "Schaffer":
			toReturn = TestFunction.Schaffer(param);
			break;
		case "Griewank":
			toReturn = TestFunction.Griewank(param);
			break;
		case "Rastr":
			toReturn = TestFunction.Rastr(param);
			break;
		case "Schwefel":
			toReturn = TestFunction.Schwefel(param);
			break;
		case "Sphere":
			toReturn = TestFunction.Sphere(param);
			break;
		}
		noOfEvalsPerGen[noOfGeneration]++;
		return -toReturn;
	}

	private void setFunctionRange() {
		switch (functionName) {
		case "Ackley":
			lower = -32.768;
			upper = 32.768;
			break;
		case "Hump6":
			lower = -3;
			upper = 3;
			break;
		case "Branin":
			lower = -5;
			upper = 15;
			break;
		case "Matyas":
			lower = -10;
			upper = 10;
			break;
		case "Beale":
			lower = -4.5;
			upper = 4.5;
			break;
		case "Rosenbrock":
			lower = -2.048;
			upper = 2.048;
			break;
		case "Schaffer":
			lower = -100;
			upper = 100;
			break;
		case "Griewank":
			lower = -600;
			upper = 600;
			break;
		case "Rastr":
			lower = -5.12;
			upper = 5.12;
			break;
		case "Schwefel":
			lower = -512.03;
			upper = 511.97;
			break;
		case "Sphere":
			lower = -5.12;
			upper = 5.12;
			break;
		}
		System.out.println("upper: " + upper + " lower: " + lower);
	}
}
